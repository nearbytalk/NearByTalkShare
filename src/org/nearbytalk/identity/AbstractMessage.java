package org.nearbytalk.identity;

import java.lang.reflect.Type;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import org.nearbytalk.exception.BadReferenceException;
import org.nearbytalk.util.Utility;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public abstract class AbstractMessage extends BaseIdentifiable implements
		IStatistical {
	
	public static final String REFERENCE_MESSAGE_KEY="referenceMessage";

	public static enum MessageType {
		PLAIN_TEXT(0), REF_UNIQUE(1), VOTE_TOPIC(2), VOTE_OF_ME(3), CHAT_BUILD(
				4), PWD_CRYPTO(5),SAME_DOING(6);

		private final int index;

		private static final MessageType[] LIST = { PLAIN_TEXT, REF_UNIQUE,
				VOTE_TOPIC, VOTE_OF_ME, CHAT_BUILD, 
				PWD_CRYPTO,SAME_DOING};
		
		public static MessageType fromIndex(int index){
			return LIST[index];
		}

		public int getIndex() {
			return index;
		}

		private MessageType(int indexSet) {
			this.index = indexSet;
		}

	}
	
	public static final String SENDER_JSON_KEY = "sender";

	public static final String MESSAGE_TYPE_JSON_KEY = "messageType";

	/**
	 * referenceDepth including self. if no reference, this is 1 if reference is
	 * a {@link LeafMessage} , depth will be 2 if reference is a
	 * CompositeMessage, depth will be reference.referenceDepth+1
	 * 
	 * this field is for client determined render depth no use for server save.
	 * 
	 */
	private int referenceDepth = 1;

	private final MessageType messageType;

	private BaseUserInfo sender;
	
	
	private AtomicInteger referencedCounter=new AtomicInteger(0);
	
	private AtomicInteger agreeCounter=new AtomicInteger(0);
	
	private AtomicInteger disagreeCounter=new AtomicInteger(0);

	/**
	 * client api construct route,idBytes is generated by digestId
	 * @param sender
	 * @param messageType
	 * @param createDate
	 */
	public AbstractMessage(BaseUserInfo sender, MessageType messageType,
			Date createDate) {
		this.sender = sender;
		this.messageType = messageType;
		this.createDate = createDate;
	}

	/**
	 * db construct route,idBytes is read from record
	 * @param idBytes
	 * @param sender
	 * @param messageType
	 * @param createDate
	 */
	public AbstractMessage(String idBytes, BaseUserInfo sender,
			MessageType messageType, Date createDate,
			int referencedCounter,int agreeCounter,int disagreeCounter) {
		super(idBytes);
		this.sender = sender;
		this.messageType = messageType;
		this.createDate = createDate;
		this.referencedCounter.set(referencedCounter);
		this.agreeCounter.set(agreeCounter);
		this.disagreeCounter.set(disagreeCounter);
	}

	public MessageType getMessageType() {
		return messageType;
	}

	public BaseUserInfo getSender() {
		return sender;
	}

	public final String anyReferenceIdBytes() {
		return getReferenceIdBytes() != null ? getReferenceIdBytes()
				: (getReferenceMessage() != null ? getReferenceMessage()
						.getIdBytes() : null);
	}

	private Date createDate;

	@Override
	public Date getCreateDate() {
		return createDate;
	}

	/**
	 * if isReferenceOther()=true and message construct from client side , this
	 * should return referenced message idBytes
	 * 
	 * @return
	 */
	public abstract String getReferenceIdBytes();

	/**
	 * if isReferenceOther()=true and message construct from server side(read
	 * from db) ,this should return referenced message
	 * 
	 * @return
	 */
	public abstract AbstractMessage getReferenceMessage();

	public abstract String asPlainText();

	/**
	 * this is a must have method ,for that client side sent message needs
	 * server side session check,so this field can not be decided when message
	 * is constructed
	 * 
	 * @param sender
	 */
	protected void setSender(ClientUserInfo sender) {
		this.sender = sender;
	}

	public int getReferenceDepth() {
		return referenceDepth;
	}

	protected void setReferenceDepth(int referenceDepth) {
		this.referenceDepth = referenceDepth;
	}

	protected void setCreateDate(Date createDate) {
		this.createDate = createDate;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result = prime * result
				+ ((createDate == null) ? 0 : createDate.hashCode());
		result = prime * result
				+ ((messageType == null) ? 0 : messageType.hashCode());
		result = prime * result + referenceDepth;
		result = prime * result + ((sender == null) ? 0 : sender.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!super.equals(obj))
			return false;
		if (getClass() != obj.getClass())
			return false;
		AbstractMessage other = (AbstractMessage) obj;

		//we do not care crossIndexes,since
		//this field is parsed manually only
		//not used for equals test

		if (!Utility.dateFuzzySame(createDate, other.createDate)) {
			return false;
		}

		if (messageType != other.messageType)
			return false;
		//agreeCounter/disagreeCounter/referencedCounter is not important
		//so do not compare them
		if (referenceDepth != other.referenceDepth)
			return false;
		if (sender == null) {
			if (other.sender != null)
				return false;
		} else if (!sender.sameStrippedUser(other.sender))
			return false;
		return true;
	}

	public boolean sameStrippedUser(AbstractMessage other) {
		if (this == other)
			return true;
		if (!super.equals(other))
			return false;

		if (!Utility.dateFuzzySame(createDate, other.createDate)) {
			return false;
		}

		if (messageType != other.messageType)
			return false;
		if (referenceDepth != other.referenceDepth)
			return false;
		if (sender == null) {
			if (other.sender != null)
				return false;
		} else if (!sender.sameStrippedUser(other.sender))
			return false;
		return true;
	}
	
	public abstract void replaceReferenceMessage(AbstractMessage toReplace);

	/**
	 * set reference message, should not be null
	 * @param message
	 * @throws BadReferenceException
	 */
	public abstract void setReferenceMessageLater(AbstractMessage message)
			throws BadReferenceException;
	
	public static class Gsoner implements JsonDeserializer<AbstractMessage> ,JsonSerializer<AbstractMessage>{

		private static final Map<MessageType, Class<? extends AbstractTextMessage>> TYPE_MAP = new HashMap<AbstractMessage.MessageType, Class<? extends AbstractTextMessage>>();

		static {
			TYPE_MAP.put(MessageType.PLAIN_TEXT, PlainTextMessage.class);
			TYPE_MAP.put(MessageType.VOTE_OF_ME, VoteOfMeMessage.class);
			TYPE_MAP.put(MessageType.VOTE_TOPIC, VoteTopicMessage.class);
			TYPE_MAP.put(MessageType.CHAT_BUILD, ChatBuildMessage.class);
			//      TODO MessageType.PWD_PROECT
		}

		@Override
		public AbstractMessage deserialize(JsonElement jsonElement, Type arg1,
				JsonDeserializationContext deserializationContext)
				throws JsonParseException {

			if (!jsonElement.isJsonObject()) {
				return null;
			}

			JsonObject jsonObject = jsonElement.getAsJsonObject();
			
			//when deserialize, exclude reference message field
			//we do not deserialize reference message .
			//(lacks context information for verify)
			//while sync between nodes, we assume the reference message
			//will be always saved first 
			
			jsonObject.remove(REFERENCE_MESSAGE_KEY);

			JsonElement typeElement = jsonObject.get(MESSAGE_TYPE_JSON_KEY);

			if (typeElement == null) {
				// can not determined type;
				return null;
			}

			MessageType type = deserializationContext.deserialize(typeElement,
					MessageType.class);

			Class<? extends AbstractTextMessage> clazz = TYPE_MAP.get(type);

			if (clazz == null) {
				return null;
			}

			AbstractMessage ret=deserializationContext.deserialize(jsonObject, clazz);
			
			if (ret==null) {
				return null;
			}
			
			ret.agreeCounter=new AtomicInteger(0);
			ret.disagreeCounter=new AtomicInteger(0);
			ret.referencedCounter=new AtomicInteger(0);
				
			ret.parseTopics();
			
			return ret;
		}

		@Override
		public JsonElement serialize(AbstractMessage src, Type typeOfSrc,
				JsonSerializationContext context) {
			
			//this is necessary ,GSON decide serializer by checking super type TypeAdaptor
			//and use default super class serialize ,leads sub-class lose fields 
			return context.serialize(src, src.getClass());
		}

	}

	/**
	 * marks this message as "invalid" or "deleted" state
	 * to emulate runtime message delete (but display original "delete")
	 * 
	 */
	public abstract void invalid();

	
	
	public abstract Set<String> getTopics();

	
	/**
	 * parse content to crossIndex list
	 * must be called manual if from json deserialize
	 * or automatically from constructor
	 * 
	 * TODO call this method from constructor
	 * 
	 */
	public abstract void parseTopics();
	
	
	

	
	
	public void increaseAgreeCounter(){
		agreeCounter.incrementAndGet();
	}
	
	public void increaseDisagreeCounter(){
		disagreeCounter.incrementAndGet();
	}
	
	public void increaseReferencedCounter(){
		referencedCounter.incrementAndGet();
	}

	public int getReferencedCounter() {
		return referencedCounter.get();
	}

	public int getAgreeCounter() {
		return agreeCounter.get();
	}

	public int getDisagreeCounter() {
		return disagreeCounter.get();
	}

	@Override
	public String toString() {
		return super.toString()+"[ref_depth=" + referenceDepth
				+ ", sender=" + sender
				+ ", topics=" + getTopics() + ", ref_counter="
				+ referencedCounter + ", agreeCounter=" + agreeCounter
				+ ", disagreeCounter=" + disagreeCounter + ", createDate="
				+ createDate + "]";
	}
	
	/**
	 * for http client json deserialize use, will not auto digestId
	 * 
	 * @param sender
	 */
	public void setSenderLater(ClientUserInfo sender) {
		setSender(sender);
	}
/**
	 * for http client json deserialize use, will not auto digestId
	 * 
	 * @param createDate
	 */
	public void setCreateDateLater(Date createDate) {
		setCreateDate(createDate);
	}
	
}
